## 重构的定义 WHAT
* 对软件内部结构的一种调整
* 关键：运用大量**微小**且保持软件行为的步骤，一步步达成大规模的修改
  （如果有人说他们的代码在重构过程中有1-2天的时间不可用，基本上可以确定，他们做的事情不是重构）
* 目的：**易理解**，**易修改**

## 重构的原因 WHY
* 改进软件的设计：程序的内部设计/架构会逐渐腐败变质。（一个重要改进方向：消除重复）  
* 使软件更容易理解
* 发现bug从而可以更长时间地保持开发的快速。
* 由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。
* **设计耐久性假说**：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。

## 何时重构 WHEN
* **三次法则**：第三次做类似的修改时进行重构
* 最佳时机：添加新功能之前（预备性重构）
* 尝试理解代码时，通过重构把自己的理解植入到了代码中，可以验证自己的理解是否无误，这份知识会保存更久，并且可以让其他人也看到。
* 有计划的重构并不是必要的，更频繁地出现在开发过程中
* code review时原作者与评审者坐在一起结对编程进行重构
* 何时不应该重构：1.不需要修改该丑陋的代码 2.不需要理解该丑陋的代码，已经被隐藏在一个API之下 3. 重写比重构更容易
* 开发者可能会经常切换开发新功能、重构两个状态。要清楚此时的状态、并且明确相应的目的和操作。比如开发完新功能后需要修改测试，而重构完成后需要运行已有测试。

## 重构的机遇和挑战（取舍的判断力）
*  延缓新功能开发：由经济利益驱动，判断是否需要先进行重构，再进行新功能开发
*  代码所有权：跨边界的修改，需要代码维护区的人员**监控**自己责任区内的修改。
*  分支：尽可能频繁地集成，将分支与主线合并
*  对测试的依赖：测试完备、速度要快；或者选择自动化重构，牺牲一些重构手法；新的流派——使用验证过的手法（Jay Bazuzi）
*  数据库的设计和重构：渐近式数据库设计、并行修改
*  为未来考虑的灵活性机制：预先思考和重构的平衡
   *  如果未来重构很困难，才会考虑现在添加灵活性机制。
   *  如果灵活性机制不会增加复杂度（如增加几个命名良好的小函数），则可以很开心地引入。
   *  等一等，待到问题理解更充分，再来着手解决
* 软件开发过程的三大实践：自测试代码、持续集成、重构
* 先进行重构，再完成后再进行性能提升。

## 遗留问题
* 自动化重构工具（可靠的、不用验证的）：能够借助**语法树**来分析和重构程序代码。
  * Eclipse, IntelliJ IDEA(JAVA)
  * 语言服务器（language server)可以软件生成语法树，给单纯文本编辑器提供API

* 缺乏测试的重构手法：
  * 验证过的重构手法（Jay Bazuzi）
  * 自动化重构工具，牺牲一些重构手法

* 其他重构的学习参考资料：
  * 《重构手册》Bill Wake
  * 《数据库重构》Ambler&Sadalage《重构HTML》Harold
  * Michael Feathers《**修改代码的艺术**》如何在缺乏测试覆盖的老旧代码库上开展重构
  * 重构网站：refactoring.com