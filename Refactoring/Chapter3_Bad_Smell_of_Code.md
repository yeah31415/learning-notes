本章提供了一些代码不好的迹象，它表明了此处可以用重构来改善。

但是并不是每一个迹象都需要进行重构，每个迹象中也存在一些不精确的程度判断。

**你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少代码行才算太长。**

在进行实际重构中，本章内容可以和后续的**重构名录**结合，不断查询和使用。

## 代码中的坏味道
| <p align="left">Bad Smell</p> |                                            <p align="left">Description</p>                                            |                     <p align="left">Refactoring solution</p> |
| :---------------------------- | :-------------------------------------------------------------------------------------------------------------------: | -----------------------------------------------------------: |
| 神秘命名                      | <p align="left">* 命名是編程中最難的兩件事之一<br>* 如果sublime想不出一个好名字，说明背后可能潜藏着更深的设计问题 <br></p> | <p align="left">改變函數聲明；变量改名；属性/字段 改名；</p> |
| 重复代码                      | <p align="left">* 阅读寻找差异困难、修改困难</p>|<p align="left">提炼函数、移动语句、函数上移</p>|
| 过长函数                      | <p align="left">* 小函数：更好的阐释力、易于分享与选择、易于命名 <br>* 关键在于函数做什么和如何做的**语义距离**<br></p>|<p align="left">提炼函数、以命令取代函数、以多态取代条件表达式、分解条件表达式</p>|
| 过长参数列表                      | <p align="left">* 如果多个函数有同样的几个参数，引入一个类就尤为有意义 </p>|<p align="left">以查询取代参数、引入参数对象、移除标记参数、保持对象完整</p>|
| 全局数据                      | <p align="left">少量的全局数据或许无妨，数量越多处理的难度指数上升。易于修改、和难以debug。 </p>|<p align="left">用函数封装变量，控制其作用域</p>|
| 可变数据                      | <p align="left">* 约束对数据的更新，降低风险，缩小作用域<br>* 单一用途；尽量把没有副作用的代码语更新变量的代码分开<br></p>|<p align="left">封装变量、拆分变量、移动语提炼函数、以查询取代派生变量、查询函数和修改函数分离</p>|
| 发散式变化                      | <p align="left">* 由于不同的原因在不同的方向上发生变化。<br>* 每次只关心一个上下文<br></p>|<p align="left">拆分阶段、搬移函数、提炼函数、提炼类</p>|
| 散弹式变化                      | <p align="left">* 由于同一个原因在不同的方向上发生类似的变化。</p>|<p align="left">搬移函数、搬移字段、函数组合成类、内联函数、内联类。可以先内联再拆分。</p>|
| 依恋情节                      | <p align="left">* 模块化：最大化内部交互、最小跨区域的交互<br>* 将总是一起变化的东西放在一块<br></p>|<p align="left">搬移函数、提炼函数</p>|
| 数据泥团                      | <p align="left">* 总是一起出现的数据应该有属于它们的对象<br>* 如果删掉众多数据中的一项，其他数据是否会失去意义<br>？</p>|<p align="left">提炼类、引入参数对象、保持对象完整</p>|
| 基本类型偏执                      | <p align="left">* 创建对自己的问题域有用的基本类型<</p>|<p align="left">以对象取代基本类型、以子类取代类型码、以多态取代条件表达式</p>|
| 重复的switch                      | <p align="left">* 每当你想增加一个选择分支时，需要找到所有的switch并逐一更新</p>|<p align="left">以多态取代条件表达式</p>|
| 循环语句                      | <p align="left">* C不支持</p>|<p align="left">以管道取代循环（map,filter）</p>|
| 冗余元素                      | <p align="left">* 重复、不需要</p>|<p align="left">内联函数、内联类、折叠继承体系</p>|
| 夸夸其谈通用性                      | <p align="left">* 你将来并不一定会用上的设计却增加了代码的复杂度<br>* 坏味道：函数的唯一用户是测试用例<br></p>|<p align="left">改变函数声明</p>|
| 临时字段                      | <p align="left">* 某个字段仅为某种特定情况而设置</p>|<p align="left">提炼类、搬移函数、引入特例（e.g.NULL对象）</p>|
| 过长的消息链                      | <p align="left">* 把使用该调用的代码提炼到一个独立的函数中</p>|<p align="left">隐藏委托关系、搬移函数、提炼函数</p>|
| 中间人                      | <p align="left">* 某个类一半以上的接口委托给其他类</p>|<p align="left">移除中间人、内联函数、以委托取代超类/子类</p>|
| 依恋情节                      | <p align="left">* 模块化：最大化内部交互、最小跨区域的交互<br>* 将总是一起变化的东西放在一块<br></p>|<p align="left">搬移函数、提炼函数</p>|
| 内幕交易                      | <p align="left">* 在模块之间大量交换数据<br>* 继承中子类对超类的了解总是超过后者的主管愿望<br></p>|<p align="left">搬移函数、搬移字段、隐藏委托关系、以委托取代子类、以委托取代超类</p>|
| 过大的类                      | <p align="left">* 观察其使用者进行拆分<br>* 将相同前缀/后缀的变量提炼<br></p>|<p align="left">提炼类、提炼超类、以子类取代类型码</p>|
| 纯数据类                      | <p align="left">* 如果是不可修改的数据容器，则可仅通过获取接口读取数据<br>* 如果是可修改的数据，意味着行为被放错了地方<br></p>|<p align="left">封装记录、搬移函数、提炼函数、拆分阶段</p>|
| 被拒绝的遗赠                      | <p align="left">* 子类不需要继承超类的函数和数据</p>|<p align="left">函数下移、字段下移、以委托取代子类/超类</p>|
| 注释                      | <p align="left">* 用途：仅记录将来的打算、和做某事的原因<br>* 当你需要写注释时，先尝试重构，让所有注释都变得多余<br></p>|<p align="left">改变函数声明、提炼函数、引入断言</p>|



